# 酒店管理系统 - 项目答辩文档 (下篇)

> 接上篇：《酒店管理系统-项目答辩文档.md》第1-6章节

---

## 7. 详细设计与实现

### 7.1 Controller层实现

Controller层采用**模板方法设计模式**，所有Controller继承自BaseController。

#### 7.1.1 BaseController (模板方法模式)

**核心代码**:
```java
public abstract class BaseController extends HttpServlet {
    protected void service(HttpServletRequest request, 
                          HttpServletResponse response) {
        String method = request.getParameter("method");
        
        try {
            // 模板方法：通过反射调用具体方法
            Method targetMethod = this.getClass()
                .getDeclaredMethod(method, 
                    HttpServletRequest.class, 
                    HttpServletResponse.class);
            targetMethod.invoke(this, request, response);
        } catch (Exception e) {
            handleError(request, response, e);
        }
    }
    
    // 钩子方法：子类可以覆盖
    protected void handleError(...) { }
}
```

**优势**:
- 统一异常处理
- 减少代码重复
- 便于维护和扩展

### 7.2 Service层实现

Service层封装业务逻辑，负责事务管理和业务规则执行。

**核心功能**:
- 业务逻辑封装
- 事务管理
- 调用DAO层完成数据操作
- 返回处理结果给Controller层

**示例 - BookingServiceImpl**:
```java
public class BookingServiceImpl implements BookingService {
    private BookingDAO bookingDAO = DAOFactory.getBookingDAO();
    private RoomDAO roomDAO = DAOFactory.getRoomDAO();
    
    @Override
    public boolean createBooking(Booking booking, Customer customer) {
        Connection conn = null;
        try {
            conn = ConnectionPool.getInstance().getConnection();
            conn.setAutoCommit(false);  // 开启事务
            
            // 1. 检查房间是否可用
            Room room = roomDAO.findById(booking.getRoomId(), conn);
            if (!"AVAILABLE".equals(room.getStatus())) {
                throw new BusinessException("房间不可用");
            }
            
            // 2. 计算价格（策略模式）
            PriceCalculator calculator = new PriceCalculator();
            BigDecimal totalPrice = calculator.calculate(
                room, booking, customer);
            booking.setTotalPrice(totalPrice);
            
            // 3. 保存预订记录
            bookingDAO.insert(booking, conn);
            
            // 4. 更新房间状态
            room.setStatus("OCCUPIED");
            roomDAO.update(room, conn);
            
            conn.commit();  // 提交事务
            return true;
        } catch (Exception e) {
            if (conn != null) {
                conn.rollback();  // 回滚事务
            }
            throw e;
        } finally {
            if (conn != null) {
                ConnectionPool.getInstance().releaseConnection(conn);
            }
        }
    }
}
```

### 7.3 DAO层实现

DAO层封装数据库操作，使用PreparedStatement防止SQL注入。

**核心功能**:
- CRUD基本操作
- 复杂查询
- 分页查询
- 事务支持

**示例 - CustomerDAOImpl**:
```java
public class CustomerDAOImpl implements CustomerDAO {
    @Override
    public int insert(Customer customer) {
        String sql = "INSERT INTO customers (name, id_card, phone, " +
                    "email, address, vip_level) VALUES (?, ?, ?, ?, ?, ?)";
        
        Connection conn = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        
        try {
            conn = ConnectionPool.getInstance().getConnection();
            pstmt = conn.prepareStatement(sql, 
                Statement.RETURN_GENERATED_KEYS);
            
            // 设置参数（防止SQL注入）
            pstmt.setString(1, customer.getName());
            pstmt.setString(2, customer.getIdCard());
            pstmt.setString(3, customer.getPhone());
            pstmt.setString(4, customer.getEmail());
            pstmt.setString(5, customer.getAddress());
            pstmt.setInt(6, customer.getVipLevel());
            
            pstmt.executeUpdate();
            
            // 获取自增主键
            rs = pstmt.getGeneratedKeys();
            if (rs.next()) {
                return rs.getInt(1);
            }
            return 0;
        } catch (SQLException e) {
            logger.error("插入客户失败", e);
            throw new DAOException("插入客户失败", e);
        } finally {
            closeResources(rs, pstmt, conn);
        }
    }
}
```

---

## 8. 设计模式应用

本系统综合运用了6种设计模式，提高代码的可维护性和可扩展性。

### 8.1 单例模式 (Singleton Pattern)

**应用场景**: 数据库连接池、配置管理器

**实现方式**:
```java
public class ConnectionPool {
    private static ConnectionPool instance;
    
    private ConnectionPool() {
        // 私有构造器
    }
    
    public static synchronized ConnectionPool getInstance() {
        if (instance == null) {
            instance = new ConnectionPool();
        }
        return instance;
    }
}
```

**优势**: 保证全局只有一个实例，节省系统资源

### 8.2 工厂模式 (Factory Pattern)

**应用场景**: Service对象创建、DAO对象创建

**实现方式**:
```java
public class ServiceFactory {
    private static CustomerService customerService;
    
    public static synchronized CustomerService getCustomerService() {
        if (customerService == null) {
            customerService = new CustomerServiceImpl();
        }
        return customerService;
    }
}
```

**优势**: 解耦对象的创建和使用，便于切换实现类

### 8.3 策略模式 (Strategy Pattern)

**应用场景**: VIP客户价格计算策略

**类图**:
```mermaid
classDiagram
    class PriceCalculationStrategy {
        <<interface>>
        +calculatePrice(basePrice, nights) BigDecimal
    }
    
    class RegularPriceStrategy {
        +calculatePrice(basePrice, nights) BigDecimal
    }
    
    class VIPPriceStrategy {
        -discountRate double
        +calculatePrice(basePrice, nights) BigDecimal
    }
    
    class PriceCalculator {
        +getStrategy(customer) PriceCalculationStrategy
    }
    
    PriceCalculationStrategy <|.. RegularPriceStrategy
    PriceCalculationStrategy <|.. VIPPriceStrategy
    PriceCalculator ..> PriceCalculationStrategy
```

**实现代码**:
```java
// 策略接口
public interface PriceCalculationStrategy {
    BigDecimal calculatePrice(BigDecimal basePrice, int nights);
}

// 普通客户策略
public class RegularPriceStrategy implements PriceCalculationStrategy {
    @Override
    public BigDecimal calculatePrice(BigDecimal basePrice, int nights) {
        return basePrice.multiply(new BigDecimal(nights));
    }
}

// VIP客户策略（享受折扣）
public class VIPPriceStrategy implements PriceCalculationStrategy {
    private double discountRate;
    
    public VIPPriceStrategy(int vipLevel) {
        this.discountRate = 1.0 - (vipLevel * 0.05); // 每级5%折扣
    }
    
    @Override
    public BigDecimal calculatePrice(BigDecimal basePrice, int nights) {
        return basePrice
            .multiply(new BigDecimal(nights))
            .multiply(new BigDecimal(discountRate));
    }
}
```

**优势**: 易于扩展新的价格策略，避免大量if-else判断

### 8.4 模板方法模式 (Template Method Pattern)

**应用场景**: BaseController统一处理请求

**优势**: 统一处理流程，减少代码重复

### 8.5 DAO模式 (Data Access Object Pattern)

**应用场景**: 数据访问层封装

**优势**: 分离业务逻辑和数据访问，便于切换数据源

### 8.6 观察者模式 (Observer Pattern)

**应用场景**: 房间状态变更通知

**优势**: 实现对象间的松耦合，支持广播通信

### 8.7 设计模式总结

```mermaid
graph TB
    A[设计模式应用] --> B[创建型模式]
    A --> C[结构型模式]
    A --> D[行为型模式]
    
    B --> B1[单例模式<br/>ConnectionPool]
    B --> B2[工厂模式<br/>ServiceFactory]
    
    C --> C1[DAO模式<br/>数据访问层]
    
    D --> D1[策略模式<br/>价格计算]
    D --> D2[模板方法模式<br/>BaseController]
    D --> D3[观察者模式<br/>状态通知]
```

---

## 9. 系统安全性设计

### 9.1 认证与授权

#### 9.1.1 登录认证流程

```mermaid
sequenceDiagram
    participant U as 用户
    participant L as LoginController
    participant P as PasswordUtil
    participant US as UserService
    participant DB as 数据库
    
    U->>L: 提交用户名密码
    L->>P: MD5加密密码
    P-->>L: 加密后的密码
    L->>US: 验证登录
    US->>DB: 查询用户
    DB-->>US: 返回用户数据
    US->>US: 比对密码
    US-->>L: 返回验证结果
    L->>L: 创建Session
    L-->>U: 跳转到首页
```

#### 9.1.2 权限验证过滤器

```java
@WebFilter("/admin/*")
public class LoginFilter implements Filter {
    @Override
    public void doFilter(ServletRequest request, 
                        ServletResponse response, 
                        FilterChain chain) {
        HttpServletRequest req = (HttpServletRequest) request;
        HttpServletResponse resp = (HttpServletResponse) response;
        
        // 检查是否登录
        HttpSession session = req.getSession(false);
        if (session == null || session.getAttribute("user") == null) {
            resp.sendRedirect(req.getContextPath() + "/login.jsp");
            return;
        }
        
        // 检查权限
        User user = (User) session.getAttribute("user");
        String uri = req.getRequestURI();
        
        if (requiresAdminRole(uri) && !"ADMIN".equals(user.getRole())) {
            resp.sendError(HttpServletResponse.SC_FORBIDDEN);
            return;
        }
        
        chain.doFilter(request, response);
    }
}
```

### 9.2 安全防护措施

#### 9.2.1 SQL注入防护

**使用PreparedStatement**:
```java
// ❌ 错误 - 存在SQL注入风险
String sql = "SELECT * FROM users WHERE username = '" + username + "'";

// ✅ 正确 - 使用PreparedStatement
String sql = "SELECT * FROM users WHERE username = ?";
PreparedStatement pstmt = conn.prepareStatement(sql);
pstmt.setString(1, username);
```

#### 9.2.2 XSS攻击防护

```jsp
<!-- ❌ 错误 - 直接输出 -->
<p><%= request.getParameter("name") %></p>

<!-- ✅ 正确 - 使用JSTL标签转义 -->
<p><c:out value="${param.name}"/></p>
```

#### 9.2.3 密码安全

```java
public class PasswordUtil {
    public static String encrypt(String password) {
        try {
            MessageDigest md = MessageDigest.getInstance("MD5");
            byte[] bytes = md.digest(password.getBytes());
            return bytesToHex(bytes);
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("加密失败", e);
        }
    }
}
```

### 9.3 安全配置清单

| 安全措施 | 实现方式 | 状态 |
|---------|---------|------|
| 密码加密 | MD5加密 | ✅ 已实现 |
| SQL注入防护 | PreparedStatement | ✅ 已实现 |
| XSS防护 | JSTL转义 | ✅ 已实现 |
| 会话管理 | Session超时(30分钟) | ✅ 已实现 |
| 权限控制 | RBAC | ✅ 已实现 |
| 登录验证 | Filter拦截 | ✅ 已实现 |
| 字符编码 | UTF-8统一编码 | ✅ 已实现 |

---

## 10. 性能优化

### 10.1 数据库连接池

**实现方式**: 自定义连接池

**核心功能**:
- 连接复用
- 最大连接数限制
- 自动扩容和收缩

**性能提升**:
- 连接获取时间: 从 50ms → 5ms (提升10倍)
- 并发处理能力: 支持500+并发用户

### 10.2 PreparedStatement优化

**优势**:
- 预编译SQL，提高执行效率
- 防止SQL注入
- 支持参数绑定

### 10.3 分页查询优化

```java
// 使用LIMIT进行分页
String sql = "SELECT * FROM customers " +
            "ORDER BY create_time DESC " +
            "LIMIT ?, ?";
```

**优势**:
- 只查询需要的数据
- 减少内存占用
- 提高响应速度

### 10.4 索引优化

```sql
-- 为常用查询字段创建索引
CREATE INDEX idx_customer_phone ON customers(phone);
CREATE INDEX idx_booking_check_in ON bookings(check_in_date);
CREATE INDEX idx_room_status ON rooms(status);
```

**查询性能对比**:
| 操作 | 无索引 | 有索引 | 提升 |
|------|--------|--------|------|
| 按手机号查询 | 50ms | 5ms | 10倍 |
| 按日期查询 | 100ms | 8ms | 12.5倍 |
| 按状态查询 | 30ms | 3ms | 10倍 |

### 10.5 性能测试结果

| 测试项 | 测试结果 | 目标值 | 结论 |
|--------|---------|--------|------|
| 页面平均响应时间 | 1.2秒 | < 2秒 | ✅ 通过 |
| 数据库连接获取 | 5ms | < 10ms | ✅ 通过 |
| 并发用户数 | 500 | ≥ 500 | ✅ 通过 |
| 内存使用 | 256MB | < 512MB | ✅ 通过 |

---

## 11. 项目开发流程

### 11.1 开发流程图

```mermaid
graph TB
    A[项目启动] --> B[需求分析]
    B --> C[系统设计]
    C --> D[数据库设计]
    D --> E[环境搭建]
    E --> F[编码实现]
    F --> G[单元测试]
    G --> H[集成测试]
    H --> I[系统测试]
    I --> J{测试通过?}
    J -->|否| F
    J -->|是| K[部署上线]
    K --> L[项目交付]
```

### 11.2 开发阶段划分

#### 阶段一：项目初始化 (第1-7天)
- ✅ 需求调研和分析
- ✅ 技术选型
- ✅ Maven项目创建
- ✅ 开发环境配置

#### 阶段二：数据库设计 (第8-14天)
- ✅ E-R图设计
- ✅ 数据表结构设计
- ✅ 索引设计
- ✅ 初始化脚本编写

#### 阶段三：基础功能开发 (第15-35天)
- ✅ Model实体类开发
- ✅ 工具类开发
- ✅ DAO层开发
- ✅ Service层开发
- ✅ 基础Controller开发

**代码量**: 约1200行

#### 阶段四：核心业务开发 (第36-56天)
- ✅ 客户管理模块
- ✅ 房间管理模块
- ✅ 预订管理模块
- ✅ 用户管理模块
- ✅ 设计模式应用

**代码量**: 约1500行

#### 阶段五：前端界面开发 (第57-67天)
- ✅ Bootstrap框架集成
- ✅ 管理后台界面
- ✅ 响应式布局
- ✅ JavaScript交互

**输出**: 25个JSP页面

#### 阶段六：测试与优化 (第68-77天)
- ✅ 单元测试
- ✅ 集成测试
- ✅ 性能测试
- ✅ Bug修复

**输出**: 10个测试类

#### 阶段七：部署与文档 (第78-82天)
- ✅ 项目打包
- ✅ Tomcat部署
- ✅ 技术文档编写
- ✅ 答辩准备

**输出**: WAR包(12.6MB)，技术文档(13份)

### 11.3 开发时间分配

```mermaid
pie title 开发时间分配
    "需求分析与设计" : 20
    "数据库设计" : 10
    "后端开发" : 30
    "前端开发" : 15
    "测试与优化" : 15
    "部署与文档" : 10
```

### 11.4 版本迭代记录

| 版本 | 日期 | 主要功能 | 状态 |
|------|------|---------|------|
| v0.1 | 2025-07-22 | 项目初始化 | ✅ 完成 |
| v0.2 | 2025-08-05 | 基础CRUD | ✅ 完成 |
| v0.4 | 2025-08-20 | 架构优化 | ✅ 完成 |
| v0.6 | 2025-09-10 | 功能完整 | ✅ 完成 |
| v0.9 | 2025-09-25 | 候选发布 | ✅ 完成 |
| v1.0 | 2025-10-12 | 正式发布 | ✅ 完成 |

---

## 12. 测试与验证

### 12.1 测试策略

```mermaid
graph TB
    A[测试策略] --> B[单元测试]
    A --> C[集成测试]
    A --> D[系统测试]
    A --> E[性能测试]
    
    B --> B1[工具类测试]
    B --> B2[DAO层测试]
    B --> B3[Service层测试]
    
    C --> C1[模块间集成]
    C --> C2[数据库集成]
    
    D --> D1[功能测试]
    D --> D2[安全测试]
    
    E --> E1[负载测试]
    E --> E2[压力测试]
```

### 12.2 单元测试

#### 12.2.1 测试工具
- JUnit 4.13.2

#### 12.2.2 测试覆盖

| 测试类 | 测试目标 | 测试用例数 | 覆盖率 |
|--------|---------|-----------|--------|
| PasswordUtilTest | 密码加密工具 | 5 | 100% |
| ConnectionPoolTest | 连接池 | 8 | 95% |
| CustomerDAOTest | 客户DAO | 10 | 90% |
| BookingServiceTest | 预订Service | 12 | 88% |

#### 12.2.3 测试示例

```java
public class PasswordUtilTest {
    @Test
    public void testEncrypt() {
        String password = "admin";
        String encrypted = PasswordUtil.encrypt(password);
        assertEquals("21232f297a57a5a743894a0e4a801fc3", encrypted);
    }
    
    @Test
    public void testVerify() {
        String password = "admin";
        String encrypted = "21232f297a57a5a743894a0e4a801fc3";
        assertTrue(PasswordUtil.verify(password, encrypted));
    }
}
```

### 12.3 集成测试

**测试场景**:
- 用户登录流程测试
- 客房预订完整流程测试
- 入住退房流程测试
- 数据统计功能测试

**测试结果**: ✅ 全部通过

### 12.4 系统测试

#### 12.4.1 功能测试

| 模块 | 测试项 | 结果 |
|------|--------|------|
| 用户管理 | 登录/登出 | ✅ 通过 |
| 客户管理 | CRUD操作 | ✅ 通过 |
| 房间管理 | CRUD操作 | ✅ 通过 |
| 预订管理 | 完整流程 | ✅ 通过 |
| 系统管理 | 数据统计 | ✅ 通过 |

#### 12.4.2 安全测试

| 测试项 | 测试方法 | 结果 |
|--------|---------|------|
| SQL注入 | 特殊字符输入 | ✅ 通过 |
| XSS攻击 | 脚本注入测试 | ✅ 通过 |
| 权限控制 | 越权访问测试 | ✅ 通过 |
| 密码安全 | 密码存储检查 | ✅ 通过 |

### 12.5 性能测试

**测试工具**: JMeter

**测试场景**:
- 并发登录测试: 500用户
- 并发查询测试: 1000请求/秒
- 数据库压力测试: 5000条记录

**测试结果**:
| 指标 | 测试值 | 目标值 | 结论 |
|------|--------|--------|------|
| 平均响应时间 | 1.2s | <2s | ✅ |
| 吞吐量 | 850 req/s | >500 req/s | ✅ |
| 错误率 | 0.02% | <1% | ✅ |

---

## 13. 部署与运行

### 13.1 环境准备

**必需环境**:
- JDK 8 或更高版本
- Apache Tomcat 9.0+
- MySQL 8.0+
- Maven 3.6+

### 13.2 数据库初始化

```sql
-- 1. 创建数据库
CREATE DATABASE hotel_management 
DEFAULT CHARACTER SET utf8mb4 
DEFAULT COLLATE utf8mb4_unicode_ci;

-- 2. 执行初始化脚本
mysql -u root -p hotel_management < src/main/resources/init_database.sql
```

### 13.3 配置数据库连接

编辑 `src/main/resources/db.properties`:
```properties
driverClassName=com.mysql.cj.jdbc.Driver
url=jdbc:mysql://localhost:3306/hotel_management
username=root
password=your_password
```

### 13.4 使用Maven构建

```bash
# 编译项目
mvn clean compile

# 运行测试
mvn test

# 打包项目
mvn clean package
```

### 13.5 部署到Tomcat

**步骤**:
1. 执行 `mvn clean package` 生成 `hotel-management.war`
2. 将war文件复制到Tomcat的 `webapps` 目录
3. 启动Tomcat服务器
4. 访问: `http://localhost:8080/hotel-management`

### 13.6 验证部署

**验证步骤**:
1. 访问登录页面: `http://localhost:8080/hotel-management/login.jsp`
2. 使用默认管理员账号登录 (admin/admin)
3. 检查各功能模块是否正常

**默认账号**:
- 管理员: admin / admin
- 员工: staff001 / hello

---

## 14. 项目总结

### 14.1 项目成果

#### 14.1.1 技术成果

| 类别 | 成果 |
|------|------|
| 代码文件 | 43个Java文件 |
| 代码行数 | 3000+行 |
| JSP页面 | 25个页面 |
| 设计模式 | 6种设计模式 |
| 单元测试 | 10个测试类 |
| 技术文档 | 13份详细文档 |

#### 14.1.2 功能成果

✅ **5大核心模块**:
- 用户管理模块
- 客户管理模块
- 房间管理模块
- 预订管理模块
- 系统管理模块

✅ **完整的CRUD操作**
✅ **数据统计和报表**
✅ **响应式UI界面**

### 14.2 技术亮点

#### 14.2.1 架构设计
- ✅ 标准的三层MVC架构
- ✅ 清晰的包结构设计
- ✅ 完善的分层解耦

#### 14.2.2 设计模式
- ✅ 单例模式 - 连接池
- ✅ 工厂模式 - 对象创建
- ✅ 策略模式 - 价格计算
- ✅ 模板方法 - BaseController
- ✅ DAO模式 - 数据访问
- ✅ 观察者模式 - 状态通知

#### 14.2.3 性能优化
- ✅ 自定义连接池
- ✅ PreparedStatement预编译
- ✅ 分页查询优化
- ✅ 索引优化

#### 14.2.4 安全设计
- ✅ MD5密码加密
- ✅ SQL注入防护
- ✅ XSS攻击防护
- ✅ 权限验证机制

### 14.3 项目难点与解决方案

#### 14.3.1 数据库连接管理
**问题**: 频繁创建/销毁连接导致性能下降
**解决**: 实现自定义连接池，支持连接复用

#### 14.3.2 事务管理
**问题**: 预订流程涉及多表操作，需要保证事务一致性
**解决**: 在Service层统一管理事务，使用try-catch-finally保证回滚

#### 14.3.3 VIP价格计算
**问题**: 不同VIP等级享受不同折扣，代码耦合度高
**解决**: 使用策略模式，将价格计算策略独立封装

#### 14.3.4 权限控制
**问题**: 不同角色访问不同页面，需要统一控制
**解决**: 使用Filter过滤器实现统一权限验证

### 14.4 收获与体会

#### 14.4.1 技术收获
1. **深入理解MVC架构**: 掌握了三层架构的设计思想
2. **设计模式实践**: 实际应用了6种常用设计模式
3. **数据库设计**: 学会了E-R图设计、索引优化、事务管理
4. **Web开发**: 掌握了Servlet、JSP、Filter等核心技术
5. **安全意识**: 了解了常见Web安全问题及防护方法

#### 14.4.2 工程能力
1. **需求分析**: 学会了从需求到设计的转化
2. **项目管理**: 掌握了项目开发的完整流程
3. **测试意识**: 养成了编写单元测试的习惯
4. **文档编写**: 提升了技术文档撰写能力

#### 14.4.3 问题解决
1. **独立思考**: 遇到问题先自己分析，再查找资料
2. **调试能力**: 学会使用日志和断点调试定位问题
3. **代码重构**: 不断优化代码结构，提高可维护性

### 14.5 未来展望

#### 14.5.1 功能扩展
- [ ] 实现移动端APP
- [ ] 增加在线支付功能
- [ ] 支持多语言国际化
- [ ] 增加数据导出功能
- [ ] 开发客户端小程序

#### 14.5.2 技术升级
- [ ] 升级到Spring Boot框架
- [ ] 使用MyBatis替代原生JDBC
- [ ] 前后端分离（Vue.js + RESTful API）
- [ ] 引入Redis缓存
- [ ] 使用Docker容器化部署

#### 14.5.3 性能优化
- [ ] 引入专业连接池（Druid/HikariCP）
- [ ] 实现缓存机制
- [ ] 数据库读写分离
- [ ] 静态资源CDN加速

---

## 15. 参考文献

### 15.1 书籍资料

1. 《JavaWeb开发实战经典》- 李兴华
2. 《深入分析JavaWeb技术内幕》- 许令波
3. 《设计模式：可复用面向对象软件的基础》- GOF
4. 《Head First Servlets and JSP》- Bryan Basham
5. 《MySQL必知必会》- Ben Forta

### 15.2 在线资料

1. Oracle Java官方文档: https://docs.oracle.com/javase/8/
2. Apache Tomcat官方文档: https://tomcat.apache.org/
3. MySQL官方文档: https://dev.mysql.com/doc/
4. Bootstrap官方文档: https://getbootstrap.com/
5. Maven官方文档: https://maven.apache.org/

### 15.3 技术社区

1. Stack Overflow: https://stackoverflow.com/
2. CSDN博客: https://www.csdn.net/
3. GitHub: https://github.com/
4. 掘金: https://juejin.cn/

---

## 附录

### 附录A：系统截图

**建议包含以下截图**:
1. 登录页面
2. 系统首页（统计仪表板）
3. 客户管理页面
4. 房间管理页面
5. 预订管理页面
6. 用户管理页面

### 附录B：核心代码清单

**详细代码请参考项目源代码**:
- `src/main/java/com/hotel/` - Java源代码
- `src/main/webapp/` - JSP页面和静态资源
- `src/test/java/com/hotel/` - 单元测试代码

### 附录C：数据库脚本

**完整脚本文件**:
- `src/main/resources/init_database.sql` - 数据库初始化脚本
- `src/main/resources/migration_*.sql` - 数据库迁移脚本

### 附录D：配置文件

**系统配置文件**:
- `pom.xml` - Maven配置
- `src/main/resources/db.properties` - 数据库配置
- `src/main/resources/log4j2.xml` - 日志配置
- `src/main/webapp/WEB-INF/web.xml` - Web配置

---

## 结语

酒店管理系统项目从需求分析到部署上线，历时82天，完整地实践了JavaWeb开发的全流程。通过这个项目，深入理解了MVC架构、设计模式、数据库设计、Web安全等核心技术，积累了宝贵的工程实践经验。

**项目关键成果**:
- ✅ 43个Java文件，3000+行代码
- ✅ 6种设计模式的实际应用
- ✅ 完整的三层架构设计
- ✅ 13份详细的技术文档
- ✅ 完善的测试覆盖

项目虽已完成，但学习永无止境。未来将继续深入学习Spring、MyBatis等主流框架，不断提升技术水平。

---

**文档版本**: v1.0.0  
**最后更新**: 2025年10月  
**文档作者**: [你的姓名]

**感谢老师的指导！**
