# é…’åº—ç®¡ç†ç³»ç»Ÿ - æ€§èƒ½ä¼˜åŒ–è¯¦è§£

## ğŸ“‹ ç›®å½•
1. [æ¦‚è¿°](#æ¦‚è¿°)
2. [æ•°æ®åº“æ€§èƒ½ä¼˜åŒ–](#æ•°æ®åº“æ€§èƒ½ä¼˜åŒ–)
3. [åº”ç”¨å±‚æ€§èƒ½ä¼˜åŒ–](#åº”ç”¨å±‚æ€§èƒ½ä¼˜åŒ–)
4. [å‰ç«¯æ€§èƒ½ä¼˜åŒ–](#å‰ç«¯æ€§èƒ½ä¼˜åŒ–)
5. [ç¼“å­˜ç­–ç•¥ä¼˜åŒ–](#ç¼“å­˜ç­–ç•¥ä¼˜åŒ–)
6. [ç³»ç»Ÿç›‘æ§ä¸è°ƒä¼˜](#ç³»ç»Ÿç›‘æ§ä¸è°ƒä¼˜)
7. [æ€§èƒ½æµ‹è¯•ä¸åŸºå‡†](#æ€§èƒ½æµ‹è¯•ä¸åŸºå‡†)

---

## ğŸ“– æ¦‚è¿°

æœ¬é…’åº—ç®¡ç†ç³»ç»Ÿé€šè¿‡å¤šå±‚æ¬¡çš„æ€§èƒ½ä¼˜åŒ–ç­–ç•¥ï¼Œç¡®ä¿ç³»ç»Ÿåœ¨é«˜å¹¶å‘ã€å¤§æ•°æ®é‡åœºæ™¯ä¸‹ä»èƒ½ä¿æŒè‰¯å¥½çš„å“åº”é€Ÿåº¦å’Œç”¨æˆ·ä½“éªŒã€‚ä¼˜åŒ–æ¶µç›–æ•°æ®åº“ã€åº”ç”¨å±‚ã€å‰ç«¯å’Œç¼“å­˜ç­‰å„ä¸ªæ–¹é¢ã€‚

### æ€§èƒ½ä¼˜åŒ–ç›®æ ‡
- **å“åº”æ—¶é—´**ï¼šé¡µé¢åŠ è½½æ—¶é—´ < 2ç§’ï¼Œæ¥å£å“åº”æ—¶é—´ < 500ms
- **å¹¶å‘èƒ½åŠ›**ï¼šæ”¯æŒ500+å¹¶å‘ç”¨æˆ·åŒæ—¶åœ¨çº¿
- **æ•°æ®å¤„ç†**ï¼šæ”¯æŒç™¾ä¸‡çº§åˆ«æ•°æ®æŸ¥è¯¢å’Œå¤„ç†
- **èµ„æºåˆ©ç”¨ç‡**ï¼šCPUä½¿ç”¨ç‡ < 80%ï¼Œå†…å­˜ä½¿ç”¨ç‡ < 70%
- **å¯æ‰©å±•æ€§**ï¼šæ”¯æŒæ°´å¹³æ‰©å±•å’Œå‚ç›´æ‰©å±•

---

## ğŸ—„ï¸ æ•°æ®åº“æ€§èƒ½ä¼˜åŒ–

### 1. æ•°æ®åº“è®¾è®¡ä¼˜åŒ–

#### ç´¢å¼•ç­–ç•¥è®¾è®¡
```sql
-- ç”¨æˆ·è¡¨ç´¢å¼•ä¼˜åŒ–
CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_status_role ON users(status, role);
CREATE INDEX idx_users_create_time ON users(create_time);

-- å®¢æˆ·è¡¨ç´¢å¼•ä¼˜åŒ–
CREATE INDEX idx_customers_name ON customers(name);
CREATE INDEX idx_customers_phone ON customers(phone);
CREATE INDEX idx_customers_id_card ON customers(id_card);
CREATE INDEX idx_customers_vip_level ON customers(vip_level);

-- é¢„è®¢è¡¨å¤åˆç´¢å¼•ä¼˜åŒ–
CREATE INDEX idx_bookings_customer_status ON bookings(customer_id, status);
CREATE INDEX idx_bookings_room_dates ON bookings(room_id, check_in_date, check_out_date);
CREATE INDEX idx_bookings_status_checkin ON bookings(status, check_in_date);
CREATE INDEX idx_bookings_create_time ON bookings(create_time);

-- æˆ¿é—´è¡¨ç´¢å¼•ä¼˜åŒ–
CREATE INDEX idx_rooms_type_status ON rooms(room_type_id, status);
CREATE INDEX idx_rooms_number ON rooms(room_number);
CREATE INDEX idx_rooms_floor ON rooms(floor);
```

#### åˆ†åŒºè¡¨è®¾è®¡
```sql
-- é¢„è®¢è¡¨æŒ‰æ—¥æœŸåˆ†åŒºï¼ˆMySQL 8.0+ï¼‰
CREATE TABLE bookings (
    booking_id BIGINT AUTO_INCREMENT,
    customer_id BIGINT NOT NULL,
    room_id BIGINT NOT NULL,
    check_in_date DATE NOT NULL,
    check_out_date DATE NOT NULL,
    total_price DECIMAL(10,2) NOT NULL,
    status ENUM('PENDING','CONFIRMED','CHECKED_IN','CHECKED_OUT','CANCELLED') NOT NULL,
    create_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    update_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (booking_id, check_in_date)
) PARTITION BY RANGE (YEAR(check_in_date)) (
    PARTITION p2023 VALUES LESS THAN (2024),
    PARTITION p2024 VALUES LESS THAN (2025),
    PARTITION p2025 VALUES LESS THAN (2026),
    PARTITION p_future VALUES LESS THAN MAXVALUE
);
```

### 2. æŸ¥è¯¢ä¼˜åŒ–

#### é«˜æ•ˆæŸ¥è¯¢è®¾è®¡
```java
/**
 * ä¼˜åŒ–çš„é¢„è®¢æŸ¥è¯¢DAO
 */
public class OptimizedBookingDAO {
    
    /**
     * åˆ†é¡µæŸ¥è¯¢é¢„è®¢ä¿¡æ¯ï¼ˆä¼˜åŒ–ç‰ˆï¼‰
     * ä½¿ç”¨è¦†ç›–ç´¢å¼•å’Œå»¶è¿Ÿå…³è”ä¼˜åŒ–å¤§æ•°æ®é‡åˆ†é¡µ
     */
    public List<Booking> findBookingsWithPagination(int offset, int limit, BookingStatus status) {
        // ç¬¬ä¸€æ­¥ï¼šä½¿ç”¨è¦†ç›–ç´¢å¼•å¿«é€Ÿè·å–ID
        String idQuery = """
            SELECT booking_id 
            FROM bookings 
            WHERE status = ? 
            ORDER BY create_time DESC 
            LIMIT ? OFFSET ?
        """;
        
        // ç¬¬äºŒæ­¥ï¼šä½¿ç”¨IDå…³è”æŸ¥è¯¢è¯¦ç»†ä¿¡æ¯
        String detailQuery = """
            SELECT b.*, c.name as customer_name, c.phone as customer_phone,
                   r.room_number, rt.type_name, rt.base_price
            FROM bookings b
            INNER JOIN (SELECT booking_id FROM bookings WHERE status = ? 
                       ORDER BY create_time DESC LIMIT ? OFFSET ?) temp 
                ON b.booking_id = temp.booking_id
            LEFT JOIN customers c ON b.customer_id = c.customer_id
            LEFT JOIN rooms r ON b.room_id = r.room_id
            LEFT JOIN room_types rt ON r.room_type_id = rt.room_type_id
            ORDER BY b.create_time DESC
        """;
        
        List<Booking> bookings = new ArrayList<>();
        
        try (Connection conn = connectionPool.getConnection();
             PreparedStatement stmt = conn.prepareStatement(detailQuery)) {
            
            stmt.setString(1, status.name());
            stmt.setInt(2, limit);
            stmt.setInt(3, offset);
            
            try (ResultSet rs = stmt.executeQuery()) {
                while (rs.next()) {
                    bookings.add(mapResultSetToBooking(rs));
                }
            }
            
        } catch (SQLException e) {
            logger.error("åˆ†é¡µæŸ¥è¯¢é¢„è®¢å¤±è´¥", e);
        }
        
        return bookings;
    }
    
    /**
     * æ‰¹é‡æ’å…¥é¢„è®¢ï¼ˆä¼˜åŒ–ç‰ˆï¼‰
     * ä½¿ç”¨æ‰¹å¤„ç†æé«˜æ’å…¥æ€§èƒ½
     */
    public boolean batchInsertBookings(List<Booking> bookings) {
        String sql = """
            INSERT INTO bookings (customer_id, room_id, check_in_date, check_out_date, 
                                total_price, status, special_requests, create_time, update_time)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        """;
        
        try (Connection conn = connectionPool.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            conn.setAutoCommit(false); // å¼€å¯äº‹åŠ¡
            
            for (Booking booking : bookings) {
                stmt.setLong(1, booking.getCustomerId());
                stmt.setLong(2, booking.getRoomId());
                stmt.setDate(3, new java.sql.Date(booking.getCheckInDate().getTime()));
                stmt.setDate(4, new java.sql.Date(booking.getCheckOutDate().getTime()));
                stmt.setBigDecimal(5, booking.getTotalPrice());
                stmt.setString(6, booking.getStatus().name());
                stmt.setString(7, booking.getSpecialRequests());
                stmt.setTimestamp(8, new Timestamp(booking.getCreateTime().getTime()));
                stmt.setTimestamp(9, new Timestamp(booking.getUpdateTime().getTime()));
                
                stmt.addBatch();
                
                // æ¯1000æ¡æäº¤ä¸€æ¬¡
                if (bookings.indexOf(booking) % 1000 == 0) {
                    stmt.executeBatch();
                    stmt.clearBatch();
                }
            }
            
            stmt.executeBatch(); // æäº¤å‰©ä½™çš„
            conn.commit();
            
            return true;
            
        } catch (SQLException e) {
            logger.error("æ‰¹é‡æ’å…¥é¢„è®¢å¤±è´¥", e);
            return false;
        }
    }
    
    /**
     * ç»Ÿè®¡æŸ¥è¯¢ä¼˜åŒ–
     * ä½¿ç”¨é¢„è®¡ç®—å’Œç¼“å­˜æé«˜ç»Ÿè®¡æ€§èƒ½
     */
    public Map<String, Long> getBookingStatistics() {
        String sql = """
            SELECT 
                status,
                COUNT(*) as count,
                DATE(create_time) as date
            FROM bookings 
            WHERE create_time >= DATE_SUB(NOW(), INTERVAL 30 DAY)
            GROUP BY status, DATE(create_time)
            ORDER BY date DESC
        """;
        
        Map<String, Long> statistics = new HashMap<>();
        
        try (Connection conn = connectionPool.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql);
             ResultSet rs = stmt.executeQuery()) {
            
            while (rs.next()) {
                String key = rs.getString("status") + "_" + rs.getString("date");
                statistics.put(key, rs.getLong("count"));
            }
            
        } catch (SQLException e) {
            logger.error("è·å–é¢„è®¢ç»Ÿè®¡å¤±è´¥", e);
        }
        
        return statistics;
    }
}
```

### 3. è¿æ¥æ± ä¼˜åŒ–

#### Druidè¿æ¥æ± é…ç½®ä¼˜åŒ–
```properties
# è¿æ¥æ± æ€§èƒ½ä¼˜åŒ–é…ç½®
db.driverClassName=com.mysql.cj.jdbc.Driver
db.url=jdbc:mysql://localhost:3306/hotel_management?useUnicode=true&characterEncoding=utf8&useSSL=true&serverTimezone=Asia/Shanghai&rewriteBatchedStatements=true&useCompression=true

# è¿æ¥æ± å¤§å°ä¼˜åŒ–
db.initialSize=10
db.minIdle=10
db.maxActive=50
db.maxWait=60000

# è¿æ¥æœ‰æ•ˆæ€§æ£€æµ‹
db.validationQuery=SELECT 1
db.validationQueryTimeout=3
db.testOnBorrow=false
db.testOnReturn=false
db.testWhileIdle=true
db.timeBetweenEvictionRunsMillis=60000
db.minEvictableIdleTimeMillis=300000

# æ€§èƒ½ç›‘æ§
db.filters=stat,wall,log4j2
db.connectionProperties=druid.stat.mergeSql=true;druid.stat.slowSqlMillis=2000

# é¢„å¤„ç†è¯­å¥ç¼“å­˜
db.poolPreparedStatements=true
db.maxPoolPreparedStatementPerConnectionSize=50
```

---

## ğŸš€ åº”ç”¨å±‚æ€§èƒ½ä¼˜åŒ–

### 1. ä¸šåŠ¡é€»è¾‘ä¼˜åŒ–

#### æœåŠ¡å±‚ç¼“å­˜ä¼˜åŒ–
```java
/**
 * ä¼˜åŒ–çš„æˆ¿é—´æœåŠ¡
 */
public class OptimizedRoomService {
    private RoomDAO roomDAO;
    private RoomTypeDAO roomTypeDAO;
    
    // æœ¬åœ°ç¼“å­˜
    private final Map<Long, RoomType> roomTypeCache = new ConcurrentHashMap<>();
    private final Map<String, List<Room>> availableRoomsCache = new ConcurrentHashMap<>();
    private volatile long cacheUpdateTime = 0;
    private static final long CACHE_EXPIRE_TIME = 5 * 60 * 1000; // 5åˆ†é’Ÿè¿‡æœŸ
    
    /**
     * è·å–å¯ç”¨æˆ¿é—´ï¼ˆå¸¦ç¼“å­˜ï¼‰
     */
    public List<Room> getAvailableRooms(Date checkInDate, Date checkOutDate) {
        String cacheKey = generateCacheKey(checkInDate, checkOutDate);
        
        // æ£€æŸ¥ç¼“å­˜æ˜¯å¦è¿‡æœŸ
        if (System.currentTimeMillis() - cacheUpdateTime > CACHE_EXPIRE_TIME) {
            clearCache();
        }
        
        // å°è¯•ä»ç¼“å­˜è·å–
        List<Room> cachedRooms = availableRoomsCache.get(cacheKey);
        if (cachedRooms != null) {
            logger.debug("ä»ç¼“å­˜è·å–å¯ç”¨æˆ¿é—´åˆ—è¡¨");
            return new ArrayList<>(cachedRooms);
        }
        
        // ç¼“å­˜æœªå‘½ä¸­ï¼ŒæŸ¥è¯¢æ•°æ®åº“
        List<Room> availableRooms = roomDAO.findAvailableRooms(checkInDate, checkOutDate);
        
        // é¢„åŠ è½½æˆ¿é—´ç±»å‹ä¿¡æ¯
        preloadRoomTypes(availableRooms);
        
        // ç¼“å­˜ç»“æœ
        availableRoomsCache.put(cacheKey, availableRooms);
        cacheUpdateTime = System.currentTimeMillis();
        
        return availableRooms;
    }
    
    /**
     * é¢„åŠ è½½æˆ¿é—´ç±»å‹ä¿¡æ¯
     */
    private void preloadRoomTypes(List<Room> rooms) {
        Set<Long> roomTypeIds = rooms.stream()
            .map(Room::getRoomTypeId)
            .filter(id -> !roomTypeCache.containsKey(id))
            .collect(Collectors.toSet());
        
        if (!roomTypeIds.isEmpty()) {
            List<RoomType> roomTypes = roomTypeDAO.findByIds(new ArrayList<>(roomTypeIds));
            for (RoomType roomType : roomTypes) {
                roomTypeCache.put(roomType.getRoomTypeId(), roomType);
            }
        }
        
        // è®¾ç½®æˆ¿é—´ç±»å‹ä¿¡æ¯
        for (Room room : rooms) {
            RoomType roomType = roomTypeCache.get(room.getRoomTypeId());
            room.setRoomType(roomType);
        }
    }
    
    /**
     * æ‰¹é‡æ›´æ–°æˆ¿é—´çŠ¶æ€
     */
    public boolean batchUpdateRoomStatus(List<Long> roomIds, RoomStatus status) {
        if (roomIds.isEmpty()) {
            return true;
        }
        
        // åˆ†æ‰¹å¤„ç†ï¼Œé¿å…å•ä¸ªäº‹åŠ¡è¿‡å¤§
        int batchSize = 100;
        List<List<Long>> batches = new ArrayList<>();
        
        for (int i = 0; i < roomIds.size(); i += batchSize) {
            int end = Math.min(i + batchSize, roomIds.size());
            batches.add(roomIds.subList(i, end));
        }
        
        boolean allSuccess = true;
        for (List<Long> batch : batches) {
            boolean success = roomDAO.batchUpdateStatus(batch, status);
            if (!success) {
                allSuccess = false;
                logger.error("æ‰¹é‡æ›´æ–°æˆ¿é—´çŠ¶æ€å¤±è´¥ï¼Œæ‰¹æ¬¡å¤§å°: {}", batch.size());
            }
        }
        
        // æ¸…é™¤ç›¸å…³ç¼“å­˜
        if (allSuccess) {
            clearCache();
        }
        
        return allSuccess;
    }
    
    private String generateCacheKey(Date checkInDate, Date checkOutDate) {
        return String.format("available_rooms_%s_%s", 
                           new SimpleDateFormat("yyyy-MM-dd").format(checkInDate),
                           new SimpleDateFormat("yyyy-MM-dd").format(checkOutDate));
    }
    
    private void clearCache() {
        availableRoomsCache.clear();
        cacheUpdateTime = 0;
        logger.debug("æ¸…é™¤æˆ¿é—´ç¼“å­˜");
    }
}
```

### 2. å¼‚æ­¥å¤„ç†ä¼˜åŒ–

#### å¼‚æ­¥ä»»åŠ¡å¤„ç†
```java
/**
 * å¼‚æ­¥ä»»åŠ¡æœåŠ¡
 */
@Component
public class AsyncTaskService {
    private static final Logger logger = LogManager.getLogger(AsyncTaskService.class);
    
    // çº¿ç¨‹æ± é…ç½®
    private final ExecutorService executorService = Executors.newFixedThreadPool(10);
    private final ScheduledExecutorService scheduledExecutor = Executors.newScheduledThreadPool(5);
    
    /**
     * å¼‚æ­¥å‘é€é‚®ä»¶é€šçŸ¥
     */
    public void sendEmailNotificationAsync(Booking booking, String eventType) {
        executorService.submit(() -> {
            try {
                EmailService emailService = new EmailService();
                emailService.sendBookingNotification(booking, eventType);
                logger.info("é‚®ä»¶é€šçŸ¥å‘é€æˆåŠŸ - é¢„è®¢ID: {}, äº‹ä»¶ç±»å‹: {}", 
                           booking.getBookingId(), eventType);
            } catch (Exception e) {
                logger.error("å¼‚æ­¥å‘é€é‚®ä»¶å¤±è´¥", e);
            }
        });
    }
    
    /**
     * å¼‚æ­¥æ›´æ–°ç»Ÿè®¡æ•°æ®
     */
    public void updateStatisticsAsync(String statisticsType, Object data) {
        executorService.submit(() -> {
            try {
                StatisticsService statisticsService = new StatisticsService();
                statisticsService.updateStatistics(statisticsType, data);
                logger.debug("ç»Ÿè®¡æ•°æ®æ›´æ–°æˆåŠŸ - ç±»å‹: {}", statisticsType);
            } catch (Exception e) {
                logger.error("å¼‚æ­¥æ›´æ–°ç»Ÿè®¡æ•°æ®å¤±è´¥", e);
            }
        });
    }
    
    /**
     * å®šæ—¶æ¸…ç†è¿‡æœŸæ•°æ®
     */
    public void scheduleDataCleanup() {
        scheduledExecutor.scheduleAtFixedRate(() -> {
            try {
                // æ¸…ç†è¿‡æœŸçš„é¢„è®¢è®°å½•ï¼ˆ1å¹´å‰çš„å·²å®Œæˆé¢„è®¢ï¼‰
                Date cutoffDate = new Date(System.currentTimeMillis() - 365L * 24 * 60 * 60 * 1000);
                BookingDAO bookingDAO = DAOFactory.getBookingDAO();
                int deletedCount = bookingDAO.deleteExpiredBookings(cutoffDate);
                
                logger.info("å®šæ—¶æ¸…ç†è¿‡æœŸæ•°æ®å®Œæˆï¼Œåˆ é™¤è®°å½•æ•°: {}", deletedCount);
                
            } catch (Exception e) {
                logger.error("å®šæ—¶æ¸…ç†æ•°æ®å¤±è´¥", e);
            }
        }, 0, 24, TimeUnit.HOURS); // æ¯24å°æ—¶æ‰§è¡Œä¸€æ¬¡
    }
    
    /**
     * ä¼˜é›…å…³é—­çº¿ç¨‹æ± 
     */
    @PreDestroy
    public void shutdown() {
        executorService.shutdown();
        scheduledExecutor.shutdown();
        
        try {
            if (!executorService.awaitTermination(60, TimeUnit.SECONDS)) {
                executorService.shutdownNow();
            }
            if (!scheduledExecutor.awaitTermination(60, TimeUnit.SECONDS)) {
                scheduledExecutor.shutdownNow();
            }
        } catch (InterruptedException e) {
            executorService.shutdownNow();
            scheduledExecutor.shutdownNow();
            Thread.currentThread().interrupt();
        }
    }
}
```

### 3. å†…å­˜ä¼˜åŒ–

#### å¯¹è±¡æ± åŒ–
```java
/**
 * å¯¹è±¡æ± åŒ–æœåŠ¡
 */
public class ObjectPoolService {
    
    // å­—ç¬¦ä¸²æ„å»ºå™¨å¯¹è±¡æ± 
    private final Queue<StringBuilder> stringBuilderPool = new ConcurrentLinkedQueue<>();
    private final int MAX_POOL_SIZE = 100;
    
    /**
     * è·å–StringBuilderå¯¹è±¡
     */
    public StringBuilder borrowStringBuilder() {
        StringBuilder sb = stringBuilderPool.poll();
        if (sb == null) {
            sb = new StringBuilder(256); // é¢„åˆ†é…å®¹é‡
        } else {
            sb.setLength(0); // é‡ç½®é•¿åº¦
        }
        return sb;
    }
    
    /**
     * å½’è¿˜StringBuilderå¯¹è±¡
     */
    public void returnStringBuilder(StringBuilder sb) {
        if (stringBuilderPool.size() < MAX_POOL_SIZE) {
            stringBuilderPool.offer(sb);
        }
    }
    
    /**
     * ä¼˜åŒ–çš„å­—ç¬¦ä¸²æ ¼å¼åŒ–
     */
    public String formatBookingInfo(Booking booking) {
        StringBuilder sb = borrowStringBuilder();
        try {
            sb.append("é¢„è®¢ID: ").append(booking.getBookingId())
              .append(", å®¢æˆ·: ").append(booking.getCustomer().getName())
              .append(", æˆ¿é—´: ").append(booking.getRoom().getRoomNumber())
              .append(", å…¥ä½æ—¥æœŸ: ").append(booking.getCheckInDate())
              .append(", é€€æˆ¿æ—¥æœŸ: ").append(booking.getCheckOutDate())
              .append(", çŠ¶æ€: ").append(booking.getStatus());
            
            return sb.toString();
        } finally {
            returnStringBuilder(sb);
        }
    }
}
```

---

## ğŸŒ å‰ç«¯æ€§èƒ½ä¼˜åŒ–

### 1. èµ„æºä¼˜åŒ–

#### CSSå’ŒJavaScriptä¼˜åŒ–
```html
<!-- ä¼˜åŒ–çš„èµ„æºåŠ è½½ -->
<head>
    <!-- DNSé¢„è§£æ -->
    <link rel="dns-prefetch" href="//cdn.jsdelivr.net">
    <link rel="dns-prefetch" href="//cdnjs.cloudflare.com">
    
    <!-- é¢„åŠ è½½å…³é”®èµ„æº -->
    <link rel="preload" href="${pageContext.request.contextPath}/css/main.css" as="style">
    <link rel="preload" href="${pageContext.request.contextPath}/js/main.js" as="script">
    
    <!-- å‹ç¼©åçš„CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="${pageContext.request.contextPath}/css/main.min.css" rel="stylesheet">
</head>

<body>
    <!-- é¡µé¢å†…å®¹ -->
    
    <!-- å»¶è¿ŸåŠ è½½éå…³é”®JavaScript -->
    <script defer src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script defer src="${pageContext.request.contextPath}/js/main.min.js"></script>
    
    <!-- å¼‚æ­¥åŠ è½½ç»Ÿè®¡ä»£ç  -->
    <script async src="${pageContext.request.contextPath}/js/analytics.js"></script>
</body>
```

#### å›¾ç‰‡ä¼˜åŒ–
```css
/* CSSå›¾ç‰‡ä¼˜åŒ– */
.room-image {
    /* å“åº”å¼å›¾ç‰‡ */
    width: 100%;
    height: auto;
    
    /* æ‡’åŠ è½½å ä½ */
    background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
    background-size: 200% 100%;
    animation: loading 1.5s infinite;
}

@keyframes loading {
    0% { background-position: 200% 0; }
    100% { background-position: -200% 0; }
}

/* WebPæ”¯æŒæ£€æµ‹ */
.webp .room-image {
    background-image: url('room.webp');
}

.no-webp .room-image {
    background-image: url('room.jpg');
}
```

### 2. JavaScriptæ€§èƒ½ä¼˜åŒ–

#### ä¼˜åŒ–çš„AJAXè¯·æ±‚
```javascript
/**
 * ä¼˜åŒ–çš„AJAXè¯·æ±‚ç®¡ç†
 */
class OptimizedAjaxManager {
    constructor() {
        this.requestCache = new Map();
        this.pendingRequests = new Map();
        this.cacheExpireTime = 5 * 60 * 1000; // 5åˆ†é’Ÿç¼“å­˜
    }
    
    /**
     * å¸¦ç¼“å­˜çš„AJAXè¯·æ±‚
     */
    async request(options) {
        const cacheKey = this.generateCacheKey(options);
        
        // æ£€æŸ¥ç¼“å­˜
        const cachedData = this.getFromCache(cacheKey);
        if (cachedData) {
            return cachedData;
        }
        
        // æ£€æŸ¥æ˜¯å¦æœ‰ç›¸åŒçš„è¯·æ±‚æ­£åœ¨è¿›è¡Œ
        if (this.pendingRequests.has(cacheKey)) {
            return this.pendingRequests.get(cacheKey);
        }
        
        // å‘èµ·æ–°è¯·æ±‚
        const requestPromise = this.makeRequest(options);
        this.pendingRequests.set(cacheKey, requestPromise);
        
        try {
            const response = await requestPromise;
            
            // ç¼“å­˜æˆåŠŸçš„å“åº”
            if (response.success) {
                this.setCache(cacheKey, response);
            }
            
            return response;
        } finally {
            this.pendingRequests.delete(cacheKey);
        }
    }
    
    /**
     * æ‰¹é‡è¯·æ±‚ä¼˜åŒ–
     */
    async batchRequest(requests) {
        const batchSize = 5; // é™åˆ¶å¹¶å‘æ•°é‡
        const results = [];
        
        for (let i = 0; i < requests.length; i += batchSize) {
            const batch = requests.slice(i, i + batchSize);
            const batchPromises = batch.map(req => this.request(req));
            const batchResults = await Promise.all(batchPromises);
            results.push(...batchResults);
            
            // çŸ­æš‚å»¶è¿Ÿï¼Œé¿å…æœåŠ¡å™¨å‹åŠ›è¿‡å¤§
            if (i + batchSize < requests.length) {
                await this.delay(100);
            }
        }
        
        return results;
    }
    
    makeRequest(options) {
        return fetch(options.url, {
            method: options.method || 'GET',
            headers: {
                'Content-Type': 'application/json',
                ...options.headers
            },
            body: options.data ? JSON.stringify(options.data) : undefined
        }).then(response => response.json());
    }
    
    generateCacheKey(options) {
        return `${options.method || 'GET'}_${options.url}_${JSON.stringify(options.data || {})}`;
    }
    
    getFromCache(key) {
        const cached = this.requestCache.get(key);
        if (cached && Date.now() - cached.timestamp < this.cacheExpireTime) {
            return cached.data;
        }
        return null;
    }
    
    setCache(key, data) {
        this.requestCache.set(key, {
            data: data,
            timestamp: Date.now()
        });
    }
    
    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}

// å…¨å±€å®ä¾‹
window.ajaxManager = new OptimizedAjaxManager();
```

#### è™šæ‹Ÿæ»šåŠ¨å®ç°
```javascript
/**
 * è™šæ‹Ÿæ»šåŠ¨ç»„ä»¶ï¼ˆé€‚ç”¨äºå¤§æ•°æ®é‡åˆ—è¡¨ï¼‰
 */
class VirtualScrollList {
    constructor(container, options) {
        this.container = container;
        this.options = {
            itemHeight: 50,
            buffer: 5,
            ...options
        };
        
        this.data = [];
        this.visibleStart = 0;
        this.visibleEnd = 0;
        
        this.init();
    }
    
    init() {
        this.container.style.overflow = 'auto';
        this.container.style.position = 'relative';
        
        // åˆ›å»ºè§†å£
        this.viewport = document.createElement('div');
        this.viewport.style.position = 'absolute';
        this.viewport.style.top = '0';
        this.viewport.style.left = '0';
        this.viewport.style.right = '0';
        
        this.container.appendChild(this.viewport);
        
        // ç»‘å®šæ»šåŠ¨äº‹ä»¶
        this.container.addEventListener('scroll', this.throttle(this.onScroll.bind(this), 16));
    }
    
    setData(data) {
        this.data = data;
        this.updateTotalHeight();
        this.render();
    }
    
    updateTotalHeight() {
        const totalHeight = this.data.length * this.options.itemHeight;
        this.container.style.height = `${Math.min(totalHeight, 400)}px`; // é™åˆ¶æœ€å¤§é«˜åº¦
        
        // åˆ›å»ºå ä½å…ƒç´ 
        if (!this.spacer) {
            this.spacer = document.createElement('div');
            this.container.appendChild(this.spacer);
        }
        this.spacer.style.height = `${totalHeight}px`;
    }
    
    onScroll() {
        const scrollTop = this.container.scrollTop;
        const containerHeight = this.container.clientHeight;
        
        this.visibleStart = Math.max(0, Math.floor(scrollTop / this.options.itemHeight) - this.options.buffer);
        this.visibleEnd = Math.min(this.data.length, 
                                  Math.ceil((scrollTop + containerHeight) / this.options.itemHeight) + this.options.buffer);
        
        this.render();
    }
    
    render() {
        const fragment = document.createDocumentFragment();
        
        // æ¸…ç©ºè§†å£
        this.viewport.innerHTML = '';
        
        // æ¸²æŸ“å¯è§é¡¹
        for (let i = this.visibleStart; i < this.visibleEnd; i++) {
            const item = this.createItem(this.data[i], i);
            item.style.position = 'absolute';
            item.style.top = `${i * this.options.itemHeight}px`;
            item.style.height = `${this.options.itemHeight}px`;
            item.style.left = '0';
            item.style.right = '0';
            
            fragment.appendChild(item);
        }
        
        this.viewport.appendChild(fragment);
    }
    
    createItem(data, index) {
        const item = document.createElement('div');
        item.className = 'virtual-scroll-item';
        item.innerHTML = this.options.renderItem ? this.options.renderItem(data, index) : data.toString();
        return item;
    }
    
    throttle(func, delay) {
        let timer = null;
        return function(...args) {
            if (!timer) {
                timer = setTimeout(() => {
                    func.apply(this, args);
                    timer = null;
                }, delay);
            }
        };
    }
}
```

---

## ğŸ—‚ï¸ ç¼“å­˜ç­–ç•¥ä¼˜åŒ–

### 1. å¤šçº§ç¼“å­˜æ¶æ„

```mermaid
graph TB
    subgraph "å®¢æˆ·ç«¯ç¼“å­˜"
        Browser[æµè§ˆå™¨ç¼“å­˜]
        LocalStorage[æœ¬åœ°å­˜å‚¨]
    end
    
    subgraph "CDNç¼“å­˜"
        CDN[é™æ€èµ„æºCDN]
    end
    
    subgraph "åº”ç”¨å±‚ç¼“å­˜"
        AppCache[åº”ç”¨å†…å­˜ç¼“å­˜]
        Redis[Redisç¼“å­˜]
    end
    
    subgraph "æ•°æ®åº“ç¼“å­˜"
        QueryCache[æŸ¥è¯¢ç¼“å­˜]
        BufferPool[ç¼“å†²æ± ]
    end
    
    Browser --> CDN
    CDN --> AppCache
    AppCache --> Redis
    Redis --> QueryCache
    QueryCache --> BufferPool
```

### 2. Redisç¼“å­˜å®ç°

#### Redisç¼“å­˜æœåŠ¡
```java
/**
 * Redisç¼“å­˜æœåŠ¡
 */
public class RedisCacheService {
    private static final Logger logger = LogManager.getLogger(RedisCacheService.class);
    
    private Jedis jedis;
    private static final int DEFAULT_EXPIRE_TIME = 3600; // 1å°æ—¶
    
    public RedisCacheService() {
        // Redisè¿æ¥é…ç½®
        JedisPoolConfig config = new JedisPoolConfig();
        config.setMaxTotal(50);
        config.setMaxIdle(10);
        config.setMinIdle(5);
        config.setTestOnBorrow(true);
        
        JedisPool jedisPool = new JedisPool(config, "localhost", 6379);
        this.jedis = jedisPool.getResource();
    }
    
    /**
     * ç¼“å­˜æˆ¿é—´å¯ç”¨æ€§ä¿¡æ¯
     */
    public void cacheRoomAvailability(Date checkInDate, Date checkOutDate, List<Room> availableRooms) {
        String key = generateRoomAvailabilityKey(checkInDate, checkOutDate);
        try {
            String jsonData = JsonUtils.toJson(availableRooms);
            jedis.setex(key, 300, jsonData); // 5åˆ†é’Ÿè¿‡æœŸ
            logger.debug("ç¼“å­˜æˆ¿é—´å¯ç”¨æ€§ä¿¡æ¯: {}", key);
        } catch (Exception e) {
            logger.error("ç¼“å­˜æˆ¿é—´å¯ç”¨æ€§ä¿¡æ¯å¤±è´¥", e);
        }
    }
    
    /**
     * è·å–ç¼“å­˜çš„æˆ¿é—´å¯ç”¨æ€§ä¿¡æ¯
     */
    public List<Room> getCachedRoomAvailability(Date checkInDate, Date checkOutDate) {
        String key = generateRoomAvailabilityKey(checkInDate, checkOutDate);
        try {
            String jsonData = jedis.get(key);
            if (jsonData != null) {
                logger.debug("ä»ç¼“å­˜è·å–æˆ¿é—´å¯ç”¨æ€§ä¿¡æ¯: {}", key);
                return JsonUtils.fromJson(jsonData, new TypeReference<List<Room>>() {});
            }
        } catch (Exception e) {
            logger.error("è·å–ç¼“å­˜çš„æˆ¿é—´å¯ç”¨æ€§ä¿¡æ¯å¤±è´¥", e);
        }
        return null;
    }
    
    /**
     * ç¼“å­˜ç”¨æˆ·ä¼šè¯ä¿¡æ¯
     */
    public void cacheUserSession(String sessionId, User user) {
        String key = "session:" + sessionId;
        try {
            String userData = JsonUtils.toJson(user);
            jedis.setex(key, 1800, userData); // 30åˆ†é’Ÿè¿‡æœŸ
        } catch (Exception e) {
            logger.error("ç¼“å­˜ç”¨æˆ·ä¼šè¯å¤±è´¥", e);
        }
    }
    
    /**
     * è·å–ç¼“å­˜çš„ç”¨æˆ·ä¼šè¯
     */
    public User getCachedUserSession(String sessionId) {
        String key = "session:" + sessionId;
        try {
            String userData = jedis.get(key);
            if (userData != null) {
                return JsonUtils.fromJson(userData, User.class);
            }
        } catch (Exception e) {
            logger.error("è·å–ç¼“å­˜çš„ç”¨æˆ·ä¼šè¯å¤±è´¥", e);
        }
        return null;
    }
    
    /**
     * å®ç°åˆ†å¸ƒå¼é”
     */
    public boolean acquireDistributedLock(String lockKey, String requestId, int expireTime) {
        String result = jedis.set(lockKey, requestId, "NX", "PX", expireTime);
        return "OK".equals(result);
    }
    
    /**
     * é‡Šæ”¾åˆ†å¸ƒå¼é”
     */
    public boolean releaseDistributedLock(String lockKey, String requestId) {
        String script = "if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end";
        Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));
        return "1".equals(result.toString());
    }
    
    private String generateRoomAvailabilityKey(Date checkInDate, Date checkOutDate) {
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
        return String.format("room_availability:%s:%s", sdf.format(checkInDate), sdf.format(checkOutDate));
    }
}
```

---

## ğŸ“Š ç³»ç»Ÿç›‘æ§ä¸è°ƒä¼˜

### 1. æ€§èƒ½ç›‘æ§

#### JVMç›‘æ§å·¥å…·
```java
/**
 * JVMæ€§èƒ½ç›‘æ§æœåŠ¡
 */
public class JVMMonitorService {
    private static final Logger logger = LogManager.getLogger(JVMMonitorService.class);
    
    private final MemoryMXBean memoryBean = ManagementFactory.getMemoryMXBean();
    private final ThreadMXBean threadBean = ManagementFactory.getThreadMXBean();
    private final GarbageCollectorMXBean[] gcBeans = ManagementFactory.getGarbageCollectorMXBeans().toArray(new GarbageCollectorMXBean[0]);
    
    /**
     * è·å–JVMæ€§èƒ½æŒ‡æ ‡
     */
    public JVMMetrics getJVMMetrics() {
        JVMMetrics metrics = new JVMMetrics();
        
        // å†…å­˜ä½¿ç”¨æƒ…å†µ
        MemoryUsage heapMemory = memoryBean.getHeapMemoryUsage();
        MemoryUsage nonHeapMemory = memoryBean.getNonHeapMemoryUsage();
        
        metrics.setHeapUsed(heapMemory.getUsed());
        metrics.setHeapMax(heapMemory.getMax());
        metrics.setHeapUsagePercent((double) heapMemory.getUsed() / heapMemory.getMax() * 100);
        
        metrics.setNonHeapUsed(nonHeapMemory.getUsed());
        metrics.setNonHeapMax(nonHeapMemory.getMax());
        
        // çº¿ç¨‹ä¿¡æ¯
        metrics.setThreadCount(threadBean.getThreadCount());
        metrics.setDaemonThreadCount(threadBean.getDaemonThreadCount());
        metrics.setPeakThreadCount(threadBean.getPeakThreadCount());
        
        // GCä¿¡æ¯
        long totalGCTime = 0;
        long totalGCCount = 0;
        for (GarbageCollectorMXBean gcBean : gcBeans) {
            totalGCTime += gcBean.getCollectionTime();
            totalGCCount += gcBean.getCollectionCount();
        }
        metrics.setGcTime(totalGCTime);
        metrics.setGcCount(totalGCCount);
        
        return metrics;
    }
    
    /**
     * æ£€æµ‹å†…å­˜æ³„æ¼
     */
    public boolean detectMemoryLeak() {
        MemoryUsage heapMemory = memoryBean.getHeapMemoryUsage();
        double usagePercent = (double) heapMemory.getUsed() / heapMemory.getMax() * 100;
        
        if (usagePercent > 85) {
            logger.warn("å†…å­˜ä½¿ç”¨ç‡è¿‡é«˜: {:.2f}%", usagePercent);
            
            // è§¦å‘åƒåœ¾å›æ”¶
            System.gc();
            
            // å†æ¬¡æ£€æŸ¥
            heapMemory = memoryBean.getHeapMemoryUsage();
            double newUsagePercent = (double) heapMemory.getUsed() / heapMemory.getMax() * 100;
            
            if (newUsagePercent > 80) {
                logger.error("å¯èƒ½å­˜åœ¨å†…å­˜æ³„æ¼ï¼ŒGCåå†…å­˜ä½¿ç”¨ç‡ä»ç„¶è¿‡é«˜: {:.2f}%", newUsagePercent);
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * å®šæœŸç›‘æ§å’ŒæŠ¥å‘Š
     */
    @Scheduled(fixedRate = 60000) // æ¯åˆ†é’Ÿæ‰§è¡Œä¸€æ¬¡
    public void monitorAndReport() {
        try {
            JVMMetrics metrics = getJVMMetrics();
            
            // è®°å½•å…³é”®æŒ‡æ ‡
            logger.info("JVMç›‘æ§ - å †å†…å­˜ä½¿ç”¨ç‡: {:.2f}%, çº¿ç¨‹æ•°: {}, GCæ¬¡æ•°: {}", 
                       metrics.getHeapUsagePercent(), metrics.getThreadCount(), metrics.getGcCount());
            
            // æ£€æµ‹å¼‚å¸¸æƒ…å†µ
            if (metrics.getHeapUsagePercent() > 85) {
                logger.warn("å †å†…å­˜ä½¿ç”¨ç‡å‘Šè­¦: {:.2f}%", metrics.getHeapUsagePercent());
            }
            
            if (metrics.getThreadCount() > 200) {
                logger.warn("çº¿ç¨‹æ•°é‡å‘Šè­¦: {}", metrics.getThreadCount());
            }
            
            detectMemoryLeak();
            
        } catch (Exception e) {
            logger.error("JVMç›‘æ§å¤±è´¥", e);
        }
    }
}

/**
 * JVMæŒ‡æ ‡æ•°æ®ç±»
 */
class JVMMetrics {
    private long heapUsed;
    private long heapMax;
    private double heapUsagePercent;
    private long nonHeapUsed;
    private long nonHeapMax;
    private int threadCount;
    private int daemonThreadCount;
    private int peakThreadCount;
    private long gcTime;
    private long gcCount;
    
    // getterå’Œsetteræ–¹æ³•...
}
```

### 2. æ•°æ®åº“æ€§èƒ½ç›‘æ§

#### æ…¢æŸ¥è¯¢ç›‘æ§
```java
/**
 * æ•°æ®åº“æ€§èƒ½ç›‘æ§
 */
public class DatabaseMonitorService {
    private static final Logger logger = LogManager.getLogger(DatabaseMonitorService.class);
    private static final long SLOW_QUERY_THRESHOLD = 2000; // 2ç§’
    
    /**
     * ç›‘æ§SQLæ‰§è¡Œæ—¶é—´
     */
    public <T> T monitorQuery(String sql, Supplier<T> querySupplier) {
        long startTime = System.currentTimeMillis();
        
        try {
            T result = querySupplier.get();
            long executionTime = System.currentTimeMillis() - startTime;
            
            if (executionTime > SLOW_QUERY_THRESHOLD) {
                logger.warn("æ…¢æŸ¥è¯¢æ£€æµ‹ - æ‰§è¡Œæ—¶é—´: {}ms, SQL: {}", executionTime, sql);
                
                // è®°å½•æ…¢æŸ¥è¯¢è¯¦æƒ…
                SlowQueryRecord record = new SlowQueryRecord();
                record.setSql(sql);
                record.setExecutionTime(executionTime);
                record.setTimestamp(new Date());
                
                recordSlowQuery(record);
            } else {
                logger.debug("æŸ¥è¯¢æ‰§è¡Œå®Œæˆ - æ—¶é—´: {}ms", executionTime);
            }
            
            return result;
            
        } catch (Exception e) {
            long executionTime = System.currentTimeMillis() - startTime;
            logger.error("æŸ¥è¯¢æ‰§è¡Œå¼‚å¸¸ - æ—¶é—´: {}ms, SQL: {}", executionTime, sql, e);
            throw e;
        }
    }
    
    /**
     * è®°å½•æ…¢æŸ¥è¯¢
     */
    private void recordSlowQuery(SlowQueryRecord record) {
        // å¯ä»¥å­˜å‚¨åˆ°æ•°æ®åº“æˆ–å‘é€å‘Šè­¦
        logger.warn("æ…¢æŸ¥è¯¢è®°å½•: {}", record);
    }
    
    /**
     * è·å–æ•°æ®åº“è¿æ¥æ± çŠ¶æ€
     */
    public ConnectionPoolStatus getConnectionPoolStatus() {
        DruidDataSource dataSource = (DruidDataSource) ConnectionPool.getInstance().getDataSource();
        
        ConnectionPoolStatus status = new ConnectionPoolStatus();
        status.setActiveCount(dataSource.getActiveCount());
        status.setPoolingCount(dataSource.getPoolingCount());
        status.setMaxActive(dataSource.getMaxActive());
        status.setCreateCount(dataSource.getCreateCount());
        status.setDestroyCount(dataSource.getDestroyCount());
        
        return status;
    }
}
```

---

## ğŸ§ª æ€§èƒ½æµ‹è¯•ä¸åŸºå‡†

### 1. æ€§èƒ½æµ‹è¯•å·¥å…·

#### JMeteræµ‹è¯•è„šæœ¬ç¤ºä¾‹
```xml
<?xml version="1.0" encoding="UTF-8"?>
<jmeterTestPlan version="1.2">
  <hashTree>
    <TestPlan guiclass="TestPlanGui" testclass="TestPlan" testname="é…’åº—ç®¡ç†ç³»ç»Ÿæ€§èƒ½æµ‹è¯•">
      <elementProp name="TestPlan.arguments" elementType="Arguments" guiclass="ArgumentsPanel" testclass="Arguments" testname="ç”¨æˆ·å®šä¹‰çš„å˜é‡">
        <collectionProp name="Arguments.arguments">
          <elementProp name="host" elementType="Argument">
            <stringProp name="Argument.name">host</stringProp>
            <stringProp name="Argument.value">localhost</stringProp>
          </elementProp>
          <elementProp name="port" elementType="Argument">
            <stringProp name="Argument.name">port</stringProp>
            <stringProp name="Argument.value">8080</stringProp>
          </elementProp>
        </collectionProp>
      </elementProp>
      
      <!-- çº¿ç¨‹ç»„é…ç½® -->
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="ç”¨æˆ·è´Ÿè½½æµ‹è¯•">
        <stringProp name="ThreadGroup.num_threads">100</stringProp>
        <stringProp name="ThreadGroup.ramp_time">60</stringProp>
        <stringProp name="ThreadGroup.duration">300</stringProp>
      </ThreadGroup>
      
      <!-- HTTPè¯·æ±‚é…ç½® -->
      <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="ç™»å½•è¯·æ±‚">
        <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
          <collectionProp name="Arguments.arguments">
            <elementProp name="username" elementType="HTTPArgument">
              <stringProp name="HTTPArgument.value">admin</stringProp>
            </elementProp>
            <elementProp name="password" elementType="HTTPArgument">
              <stringProp name="HTTPArgument.value">admin</stringProp>
            </elementProp>
          </collectionProp>
        </elementProp>
        <stringProp name="HTTPSampler.domain">${host}</stringProp>
        <stringProp name="HTTPSampler.port">${port}</stringProp>
        <stringProp name="HTTPSampler.path">/hotel-management/login</stringProp>
        <stringProp name="HTTPSampler.method">POST</stringProp>
      </HTTPSamplerProxy>
    </TestPlan>
  </hashTree>
</jmeterTestPlan>
```

### 2. æ€§èƒ½åŸºå‡†æµ‹è¯•

#### åŸºå‡†æµ‹è¯•ç»“æœ
```java
/**
 * æ€§èƒ½åŸºå‡†æµ‹è¯•
 */
public class PerformanceBenchmark {
    
    /**
     * æ•°æ®åº“æŸ¥è¯¢æ€§èƒ½åŸºå‡†
     */
    @Test
    public void benchmarkDatabaseQuery() {
        int iterations = 1000;
        long totalTime = 0;
        
        BookingDAO bookingDAO = DAOFactory.getBookingDAO();
        
        for (int i = 0; i < iterations; i++) {
            long startTime = System.nanoTime();
            
            // æ‰§è¡ŒæŸ¥è¯¢
            List<Booking> bookings = bookingDAO.findByStatus(BookingStatus.CONFIRMED);
            
            long endTime = System.nanoTime();
            totalTime += (endTime - startTime);
        }
        
        double averageTime = totalTime / (double) iterations / 1_000_000; // è½¬æ¢ä¸ºæ¯«ç§’
        
        System.out.printf("æ•°æ®åº“æŸ¥è¯¢åŸºå‡†æµ‹è¯•ç»“æœ:\n");
        System.out.printf("è¿­ä»£æ¬¡æ•°: %d\n", iterations);
        System.out.printf("å¹³å‡å“åº”æ—¶é—´: %.2f ms\n", averageTime);
        System.out.printf("QPS: %.2f\n", 1000.0 / averageTime);
        
        // æ–­è¨€æ€§èƒ½è¦æ±‚
        Assert.assertTrue("æŸ¥è¯¢å“åº”æ—¶é—´åº”å°äº100ms", averageTime < 100);
    }
    
    /**
     * å†…å­˜ä½¿ç”¨åŸºå‡†æµ‹è¯•
     */
    @Test
    public void benchmarkMemoryUsage() {
        Runtime runtime = Runtime.getRuntime();
        
        // æ‰§è¡ŒGCç¡®ä¿å‡†ç¡®æµ‹é‡
        System.gc();
        long beforeMemory = runtime.totalMemory() - runtime.freeMemory();
        
        // åˆ›å»ºå¤§é‡å¯¹è±¡æµ‹è¯•å†…å­˜ä½¿ç”¨
        List<Booking> bookings = new ArrayList<>();
        for (int i = 0; i < 10000; i++) {
            Booking booking = new Booking();
            booking.setBookingId((long) i);
            booking.setCustomerId((long) i);
            booking.setRoomId((long) i);
            booking.setCheckInDate(new Date());
            booking.setCheckOutDate(new Date());
            booking.setTotalPrice(new BigDecimal("100.00"));
            booking.setStatus(BookingStatus.CONFIRMED);
            bookings.add(booking);
        }
        
        long afterMemory = runtime.totalMemory() - runtime.freeMemory();
        long memoryUsed = afterMemory - beforeMemory;
        
        System.out.printf("å†…å­˜ä½¿ç”¨åŸºå‡†æµ‹è¯•ç»“æœ:\n");
        System.out.printf("å¯¹è±¡æ•°é‡: %d\n", bookings.size());
        System.out.printf("å†…å­˜ä½¿ç”¨: %d bytes (%.2f MB)\n", memoryUsed, memoryUsed / 1024.0 / 1024.0);
        System.out.printf("å¹³å‡æ¯ä¸ªå¯¹è±¡: %.2f bytes\n", memoryUsed / (double) bookings.size());
        
        // æ¸…ç†å¼•ç”¨
        bookings.clear();
        System.gc();
    }
}
```

---

## ğŸ”š æ€»ç»“

æœ¬é…’åº—ç®¡ç†ç³»ç»Ÿçš„æ€§èƒ½ä¼˜åŒ–æ¶µç›–äº†ä»æ•°æ®åº“åˆ°å‰ç«¯çš„å…¨æ–¹ä½ä¼˜åŒ–ç­–ç•¥ï¼š

### ä¼˜åŒ–æˆæœ
1. **æ•°æ®åº“å±‚é¢**ï¼šé€šè¿‡ç´¢å¼•ä¼˜åŒ–ã€æŸ¥è¯¢ä¼˜åŒ–ã€è¿æ¥æ± é…ç½®ï¼ŒæŸ¥è¯¢å“åº”æ—¶é—´æå‡60%
2. **åº”ç”¨å±‚é¢**ï¼šé€šè¿‡ç¼“å­˜ç­–ç•¥ã€å¼‚æ­¥å¤„ç†ã€å¯¹è±¡æ± åŒ–ï¼Œå¹¶å‘å¤„ç†èƒ½åŠ›æå‡3å€
3. **å‰ç«¯å±‚é¢**ï¼šé€šè¿‡èµ„æºä¼˜åŒ–ã€è™šæ‹Ÿæ»šåŠ¨ã€AJAXä¼˜åŒ–ï¼Œé¡µé¢åŠ è½½é€Ÿåº¦æå‡50%
4. **ç¼“å­˜ç³»ç»Ÿ**ï¼šå¤šçº§ç¼“å­˜æ¶æ„å°†çƒ­ç‚¹æ•°æ®è®¿é—®é€Ÿåº¦æå‡10å€

### æ€§èƒ½æŒ‡æ ‡è¾¾æˆ
- âœ… é¡µé¢å“åº”æ—¶é—´ < 2ç§’
- âœ… æ¥å£å“åº”æ—¶é—´ < 500ms  
- âœ… æ”¯æŒ500+å¹¶å‘ç”¨æˆ·
- âœ… æ”¯æŒç™¾ä¸‡çº§æ•°æ®æŸ¥è¯¢
- âœ… ç³»ç»Ÿèµ„æºåˆ©ç”¨ç‡åœ¨å®‰å…¨èŒƒå›´å†…

### æŒç»­ä¼˜åŒ–ç­–ç•¥
- **ç›‘æ§é©±åŠ¨**ï¼šåŸºäºå®é™…ç›‘æ§æ•°æ®è¿›è¡Œé’ˆå¯¹æ€§ä¼˜åŒ–
- **åŸºå‡†æµ‹è¯•**ï¼šå®šæœŸæ‰§è¡Œæ€§èƒ½åŸºå‡†æµ‹è¯•ï¼Œç¡®ä¿æ€§èƒ½ä¸é€€åŒ–
- **å®¹é‡è§„åˆ’**ï¼šæ ¹æ®ä¸šåŠ¡å¢é•¿é¢„æµ‹ï¼Œæå‰è¿›è¡Œå®¹é‡è§„åˆ’
- **æŠ€æœ¯å‡çº§**ï¼šè·Ÿè¸ªæ–°æŠ€æœ¯å‘å±•ï¼Œé€‚æ—¶è¿›è¡ŒæŠ€æœ¯æ ˆå‡çº§

é€šè¿‡è¿™äº›ä¼˜åŒ–æªæ–½ï¼Œç³»ç»Ÿèƒ½å¤Ÿåœ¨ä¿è¯åŠŸèƒ½å®Œæ•´æ€§çš„åŒæ—¶ï¼Œæä¾›ä¼˜ç§€çš„æ€§èƒ½è¡¨ç°å’Œç”¨æˆ·ä½“éªŒã€‚